<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Traits</title>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Traits</h1>
<div class="details">
<span id="revnumber">version 3.0.0-alpha-3</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_methods">1. Methods</a>
<ul class="sectlevel2">
<li><a href="#_public_methods">1.1. Public methods</a></li>
<li><a href="#_abstract_methods">1.2. Abstract methods</a></li>
<li><a href="#_private_methods">1.3. Private methods</a></li>
</ul>
</li>
<li><a href="#_the_meaning_of_this">2. The meaning of this</a></li>
<li><a href="#_interfaces">3. Interfaces</a></li>
<li><a href="#_properties">4. Properties</a></li>
<li><a href="#_fields">5. Fields</a>
<ul class="sectlevel2">
<li><a href="#_private_fields">5.1. Private fields</a></li>
<li><a href="#_public_fields">5.2. Public fields</a></li>
</ul>
</li>
<li><a href="#_composition_of_behaviors">6. Composition of behaviors</a></li>
<li><a href="#_overriding_default_methods">7. Overriding default methods</a></li>
<li><a href="#_extending_traits">8. Extending traits</a>
<ul class="sectlevel2">
<li><a href="#_simple_inheritance">8.1. Simple inheritance</a></li>
<li><a href="#_multiple_inheritance">8.2. Multiple inheritance</a></li>
</ul>
</li>
<li><a href="#_duck_typing_and_traits">9. Duck typing and traits</a>
<ul class="sectlevel2">
<li><a href="#_dynamic_code">9.1. Dynamic code</a></li>
<li><a href="#_dynamic_methods_in_a_trait">9.2. Dynamic methods in a trait</a></li>
</ul>
</li>
<li><a href="#_multiple_inheritance_conflicts">10. Multiple inheritance conflicts</a>
<ul class="sectlevel2">
<li><a href="#_default_conflict_resolution">10.1. Default conflict resolution</a></li>
<li><a href="#_user_conflict_resolution">10.2. User conflict resolution</a></li>
</ul>
</li>
<li><a href="#_runtime_implementation_of_traits">11. Runtime implementation of traits</a>
<ul class="sectlevel2">
<li><a href="#_implementing_a_trait_at_runtime">11.1. Implementing a trait at runtime</a></li>
<li><a href="#_implementing_multiple_traits_at_once">11.2. Implementing multiple traits at once</a></li>
</ul>
</li>
<li><a href="#_chaining_behavior">12. Chaining behavior</a>
<ul class="sectlevel2">
<li><a href="#_semantics_of_super_inside_a_trait">12.1. Semantics of super inside a trait</a></li>
</ul>
</li>
<li><a href="#_advanced_features">13. Advanced features</a>
<ul class="sectlevel2">
<li><a href="#_sam_type_coercion">13.1. SAM type coercion</a></li>
<li><a href="#_differences_with_java_8_default_methods">13.2. Differences with Java 8 default methods</a></li>
</ul>
</li>
<li><a href="#_differences_with_mixins">14. Differences with mixins</a></li>
<li><a href="#_static_methods_properties_and_fields">15. Static methods, properties and fields</a></li>
<li><a href="#_inheritance_of_state_gotchas">16. Inheritance of state gotchas</a></li>
<li><a href="#_self_types">17. Self types</a>
<ul class="sectlevel2">
<li><a href="#_type_constraints_on_traits">17.1. Type constraints on traits</a></li>
<li><a href="#traits-selftype">17.2. The @SelfType annotation</a></li>
</ul>
</li>
<li><a href="#_limitations">18. Limitations</a>
<ul class="sectlevel2">
<li><a href="#_compatibility_with_ast_transformations">18.1. Compatibility with AST transformations</a></li>
<li><a href="#_prefix_and_postfix_operations">18.2. Prefix and postfix operations</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Traits are a structural construct of the language which allows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>composition of behaviors</p>
</li>
<li>
<p>runtime implementation of interfaces</p>
</li>
<li>
<p>behavior overriding</p>
</li>
<li>
<p>compatibility with static type checking/compilation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>They can be seen as <strong>interfaces</strong> carrying both <strong>default implementations</strong> and <strong>state</strong>. A trait is defined using the
<code>trait</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declaration of a trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>declaration of a method inside a trait</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then it can be used like a normal interface using the <code>implements</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bird implements FlyingAbility {}          <i class="conum" data-value="1"></i><b>(1)</b>
def b = new Bird()                              <i class="conum" data-value="2"></i><b>(2)</b>
assert b.fly() == "I'm flying!"                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adds the trait <code>FlyingAbility</code> to the <code>Bird</code> class capabilities</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>instantiate a new <code>Bird</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the <code>Bird</code> class automatically gets the behavior of the <code>FlyingAbility</code> trait</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Traits allow a wide range of capabilities, from simple composition to testing, which are described thoroughly in this section.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_methods"><a class="anchor" href="#_methods"></a>1. Methods</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_public_methods"><a class="anchor" href="#_public_methods"></a>1.1. Public methods</h3>
<div class="paragraph">
<p>Declaring a method in a trait can be done like any regular method in a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declaration of a trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>declaration of a method inside a trait</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_abstract_methods"><a class="anchor" href="#_abstract_methods"></a>1.2. Abstract methods</h3>
<div class="paragraph">
<p>In addition, traits may declare <em>abstract</em> methods too, which therefore need to be implemented in the class implementing the trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greetable {
    abstract String name()                              <i class="conum" data-value="1"></i><b>(1)</b>
    String greeting() { "Hello, ${name()}!" }           <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>implementing class will have to declare the <code>name</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>can be mixed with a concrete method</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then the trait can be used like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person implements Greetable {                     <i class="conum" data-value="1"></i><b>(1)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>implement the trait <code>Greetable</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>since <code>name</code> was abstract, it is required to implement it</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>then <code>greeting</code> can be called</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_private_methods"><a class="anchor" href="#_private_methods"></a>1.3. Private methods</h3>
<div class="paragraph">
<p>Traits may also define private methods. Those methods will not appear in the trait contract interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    private String greetingMessage() {                      <i class="conum" data-value="1"></i><b>(1)</b>
        'Hello from a private method!'
    }
    String greet() {
        def m = greetingMessage()                           <i class="conum" data-value="2"></i><b>(2)</b>
        println m
        m
    }
}
class GreetingMachine implements Greeter {}                 <i class="conum" data-value="3"></i><b>(3)</b>
def g = new GreetingMachine()
assert g.greet() == "Hello from a private method!"          <i class="conum" data-value="4"></i><b>(4)</b>
try {
    assert g.greetingMessage()                              <i class="conum" data-value="5"></i><b>(5)</b>
} catch (MissingMethodException e) {
    println "greetingMessage is private in trait"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>define a private method <code>greetingMessage</code> in the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the public <code>greet</code> message calls <code>greetingMessage</code> by default</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>create a class implementing the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>greet</code> can be called</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>but not <code>greetingMessage</code></td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Traits only support <code>public</code> and <code>private</code> methods. Neither <code>protected</code> nor <code>package private</code> scopes are
supported.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_meaning_of_this"><a class="anchor" href="#_the_meaning_of_this"></a>2. The meaning of this</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>this</code> represents the implementing instance. Think of a trait as a superclass. This means that when you write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Introspector {
    def whoAmI() { this }
}
class Foo implements Introspector {}
def foo = new Foo()</code></pre>
</div>
</div>
<div class="paragraph">
<p>then calling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">foo.whoAmI()</code></pre>
</div>
</div>
<div class="paragraph">
<p>will return the same instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert foo.whoAmI().is(foo)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interfaces"><a class="anchor" href="#_interfaces"></a>3. Interfaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traits may implement interfaces, in which case the interfaces are declared using the <code>implements</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface Named {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    String name()
}
trait Greetable implements Named {                      <i class="conum" data-value="2"></i><b>(2)</b>
    String greeting() { "Hello, ${name()}!" }
}
class Person implements Greetable {                     <i class="conum" data-value="3"></i><b>(3)</b>
    String name() { 'Bob' }                             <i class="conum" data-value="4"></i><b>(4)</b>
}

def p = new Person()
assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="5"></i><b>(5)</b>
assert p instanceof Named                               <i class="conum" data-value="6"></i><b>(6)</b>
assert p instanceof Greetable                           <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declaration of a normal interface</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>add <code>Named</code> to the list of implemented interfaces</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>declare a class that implements the <code>Greetable</code> trait</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>implement the missing <code>name</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>the <code>greeting</code> implementation comes from the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>make sure <code>Person</code> implements the <code>Named</code> interface</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>make sure <code>Person</code> implements the <code>Greetable</code> trait</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_properties"><a class="anchor" href="#_properties"></a>4. Properties</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A trait may define properties, like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                             <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person(name: 'Bob')             <i class="conum" data-value="3"></i><b>(3)</b>
assert p.name == 'Bob'                      <i class="conum" data-value="4"></i><b>(4)</b>
assert p.getName() == 'Bob'                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declare a property <code>name</code> inside a trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>declare a class which implements the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the property is automatically made visible</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>it can be accessed using the regular property accessor</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>or using the regular getter syntax</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fields"><a class="anchor" href="#_fields"></a>5. Fields</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_private_fields"><a class="anchor" href="#_private_fields"></a>5.1. Private fields</h3>
<div class="paragraph">
<p>Since traits allow the use of private methods, it can also be interesting to use private fields to store state. Traits
will let you do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counter {
    private int count = 0                   <i class="conum" data-value="1"></i><b>(1)</b>
    int count() { count += 1; count }       <i class="conum" data-value="2"></i><b>(2)</b>
}
class Foo implements Counter {}             <i class="conum" data-value="3"></i><b>(3)</b>
def f = new Foo()
assert f.count() == 1                       <i class="conum" data-value="4"></i><b>(4)</b>
assert f.count() == 2</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declare a private field <code>count</code> inside a trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>declare a public method <code>count</code> that increments the counter and returns it</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>declare a class that implements the <code>Counter</code> trait</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the <code>count</code> method can use the private field to keep state</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This is a major difference with <a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8 virtual extension methods</a>. While virtual extension methods
do not carry state, traits can. Moreover, traits in Groovy are supported starting with Java 6, because their implementation does not rely on virtual extension methods. This
means that even if a trait can be seen from a Java class as a regular interface, that interface will <strong>not</strong> have default methods, only abstract ones.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_public_fields"><a class="anchor" href="#_public_fields"></a>5.2. Public fields</h3>
<div class="paragraph">
<p>Public fields work the same way as private fields, but in order to avoid the <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">diamond problem</a>,
field names are remapped in the implementing class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    public String name                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>
def p = new Person()                        <i class="conum" data-value="3"></i><b>(3)</b>
p.Named__name = 'Bob'                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>declare a public <strong>field</strong> inside the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>declare a class implementing the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>create an instance of that class</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the public field is available, but renamed</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The name of the field depends on the fully qualified name of the trait. All dots (<code>.</code>) in package are replaced with an underscore (<code>_</code>), and the final name includes a double underscore.
So if the type of the field is <code>String</code>, the name of the package is <code>my.package</code>, the name of the trait is <code>Foo</code> and the name of the field is <code>bar</code>,
in the implementing class, the public field will appear as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">String my_package_Foo__bar</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
While traits support public fields, it is not recommended to use them and considered as a bad practice.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_composition_of_behaviors"><a class="anchor" href="#_composition_of_behaviors"></a>6. Composition of behaviors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traits can be used to implement multiple inheritance in a controlled way. For example, we can have the following traits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>
        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>
}
trait SpeakingAbility {
    String speak() { "I'm speaking!" }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And a class implementing both traits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {} <i class="conum" data-value="1"></i><b>(1)</b>

def d = new Duck()                                      <i class="conum" data-value="2"></i><b>(2)</b>
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.speak() == "I'm speaking!"                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>Duck</code> class implements both <code>FlyingAbility</code> and <code>SpeakingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>creates a new instance of <code>Duck</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>we can call the method <code>fly</code> from <code>FlyingAbility</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>but also the method <code>speak</code> from <code>SpeakingAbility</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Traits encourage the reuse of capabilities among objects, and the creation of new classes by the composition of existing behavior.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overriding_default_methods"><a class="anchor" href="#_overriding_default_methods"></a>7. Overriding default methods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traits provide default implementations for methods, but it is possible to override them in the implementing class. For example, we
can slightly change the example above, by having a duck which quacks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Duck implements FlyingAbility, SpeakingAbility {
    String quack() { "Quack!" }                         <i class="conum" data-value="1"></i><b>(1)</b>
    String speak() { quack() }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def d = new Duck()
assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>
assert d.quack() == "Quack!"                            <i class="conum" data-value="4"></i><b>(4)</b>
assert d.speak() == "Quack!"                            <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>define a method specific to <code>Duck</code>, named <code>quack</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>override the default implementation of <code>speak</code> so that we use <code>quack</code> instead</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the duck is still flying, from the default implementation</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>quack</code> comes from the <code>Duck</code> class</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>speak</code> no longer uses the default implementation from <code>SpeakingAbility</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_traits"><a class="anchor" href="#_extending_traits"></a>8. Extending traits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_simple_inheritance"><a class="anchor" href="#_simple_inheritance"></a>8.1. Simple inheritance</h3>
<div class="paragraph">
<p>Traits may extend another trait, in which case you must use the <code>extends</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Named {
    String name                                     <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Polite extends Named {                        <i class="conum" data-value="2"></i><b>(2)</b>
    String introduce() { "Hello, I am $name" }      <i class="conum" data-value="3"></i><b>(3)</b>
}
class Person implements Polite {}
def p = new Person(name: 'Alice')                   <i class="conum" data-value="4"></i><b>(4)</b>
assert p.introduce() == 'Hello, I am Alice'         <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>Named</code> trait defines a single <code>name</code> property</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the <code>Polite</code> trait <strong>extends</strong> the <code>Named</code> trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Polite</code> adds a new method which has access to the <code>name</code> property of the super-trait</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the <code>name</code> property is visible from the <code>Person</code> class implementing <code>Polite</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>as is the <code>introduce</code> method</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_multiple_inheritance"><a class="anchor" href="#_multiple_inheritance"></a>8.2. Multiple inheritance</h3>
<div class="paragraph">
<p>Alternatively, a trait may extend multiple traits. In that case, all super traits must be declared in the <code>implements</code>
clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait WithId {                                      <i class="conum" data-value="1"></i><b>(1)</b>
    Long id
}
trait WithName {                                    <i class="conum" data-value="2"></i><b>(2)</b>
    String name
}
trait Identified implements WithId, WithName {}     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>WithId</code> trait defines the <code>id</code> property</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>WithName</code> trait defines the <code>name</code> property</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Identified</code> is a trait which inherits both <code>WithId</code> and <code>WithName</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_duck_typing_and_traits"><a class="anchor" href="#_duck_typing_and_traits"></a>9. Duck typing and traits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_dynamic_code"><a class="anchor" href="#_dynamic_code"></a>9.1. Dynamic code</h3>
<div class="paragraph">
<p>Traits can call any dynamic code, like a normal Groovy class. This means that you can, in the body of a method, call
methods which are supposed to exist in an implementing class, without having to explicitly declare them in an interface.
This means that traits are fully compatible with duck typing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SpeakingDuck {
    String speak() { quack() }                      <i class="conum" data-value="1"></i><b>(1)</b>
}
class Duck implements SpeakingDuck {
    String methodMissing(String name, args) {
        "${name.capitalize()}!"                     <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
def d = new Duck()
assert d.speak() == 'Quack!'                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>SpeakingDuck</code> expects the <code>quack</code> method to be defined</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the <code>Duck</code> class does implement the method using <em>methodMissing</em></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>calling the <code>speak</code> method triggers a call to <code>quack</code> which is handled by <code>methodMissing</code></td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_methods_in_a_trait"><a class="anchor" href="#_dynamic_methods_in_a_trait"></a>9.2. Dynamic methods in a trait</h3>
<div class="paragraph">
<p>It is also possible for a trait to implement MOP methods like <code>methodMissing</code> or <code>propertyMissing</code>, in which case implementing classes
will inherit the behavior from the trait, like in this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DynamicObject {                               <i class="conum" data-value="1"></i><b>(1)</b>
    private Map props = [:]
    def methodMissing(String name, args) {
        name.toUpperCase()
    }
    def propertyMissing(String prop) {
        props[prop]
    }
    void setProperty(String prop, Object value) {
        props[prop] = value
    }
}

class Dynamic implements DynamicObject {
    String existingProperty = 'ok'                  <i class="conum" data-value="2"></i><b>(2)</b>
    String existingMethod() { 'ok' }                <i class="conum" data-value="3"></i><b>(3)</b>
}
def d = new Dynamic()
assert d.existingProperty == 'ok'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert d.foo == null                                <i class="conum" data-value="5"></i><b>(5)</b>
d.foo = 'bar'                                       <i class="conum" data-value="6"></i><b>(6)</b>
assert d.foo == 'bar'                               <i class="conum" data-value="7"></i><b>(7)</b>
assert d.existingMethod() == 'ok'                   <i class="conum" data-value="8"></i><b>(8)</b>
assert d.someMethod() == 'SOMEMETHOD'               <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>create a trait implementing several MOP methods</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the <code>Dynamic</code> class defines a property</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the <code>Dynamic</code> class defines a method</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>calling an existing property will call the method from <code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>calling an non-existing property will call the method from the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>will call <code>setProperty</code> defined on the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>will call <code>getProperty</code> defined on the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>calling an existing method on <code>Dynamic</code></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>but calling a non existing method thanks to the trait <code>methodMissing</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_inheritance_conflicts"><a class="anchor" href="#_multiple_inheritance_conflicts"></a>10. Multiple inheritance conflicts</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_default_conflict_resolution"><a class="anchor" href="#_default_conflict_resolution"></a>10.1. Default conflict resolution</h3>
<div class="paragraph">
<p>It is possible for a class to implement multiple traits. If some trait defines a method with the same signature as a
method in another trait, we have a conflict:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A {
    String exec() { 'A' }               <i class="conum" data-value="1"></i><b>(1)</b>
}
trait B {
    String exec() { 'B' }               <i class="conum" data-value="2"></i><b>(2)</b>
}
class C implements A,B {}               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>trait <code>A</code> defines a method named <code>exec</code> returning a <code>String</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>trait <code>B</code> defines the very same method</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>class <code>C</code> implements both traits</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this case, the default behavior is that the method from the <strong>last declared trait</strong> in the <code>implements</code> clause wins.
Here, <code>B</code> is declared after <code>A</code> so the method from <code>B</code> will be picked up:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def c = new C()
assert c.exec() == 'B'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_user_conflict_resolution"><a class="anchor" href="#_user_conflict_resolution"></a>10.2. User conflict resolution</h3>
<div class="paragraph">
<p>In case this behavior is not the one you want, you can explicitly choose which method to call using the <code>Trait.super.foo</code> syntax.
In the example above, we can force to choose the method from trait A, by writing this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class C implements A,B {
    String exec() { A.super.exec() }    <i class="conum" data-value="1"></i><b>(1)</b>
}
def c = new C()
assert c.exec() == 'A'                  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>explicit call of <code>exec</code> from the trait <code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>calls the version from <code>A</code> instead of using the default resolution, which would be the one from <code>B</code></td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_runtime_implementation_of_traits"><a class="anchor" href="#_runtime_implementation_of_traits"></a>11. Runtime implementation of traits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_implementing_a_trait_at_runtime"><a class="anchor" href="#_implementing_a_trait_at_runtime"></a>11.1. Implementing a trait at runtime</h3>
<div class="paragraph">
<p>Groovy also supports implementing traits dynamically at runtime. It allows you to "decorate" an existing object using a
trait. As an example, let&#8217;s start with this trait and the following class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Extra {
    String extra() { "I'm an extra method" }            <i class="conum" data-value="1"></i><b>(1)</b>
}
class Something {                                       <i class="conum" data-value="2"></i><b>(2)</b>
    String doSomething() { 'Something' }                <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>Extra</code> trait defines an <code>extra</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the <code>Something</code> class does <strong>not</strong> implement the <code>Extra</code> trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Something</code> only defines a method <code>doSomething</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then if we do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something()
s.extra()</code></pre>
</div>
</div>
<div class="paragraph">
<p>the call to extra would fail because <code>Something</code> is not implementing <code>Extra</code>. It is possible to do it at runtime with
the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">def s = new Something() as Extra                        <i class="conum" data-value="1"></i><b>(1)</b>
s.extra()                                               <i class="conum" data-value="2"></i><b>(2)</b>
s.doSomething()                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>use of the <strong>as</strong> keyword to coerce an object to a trait <strong>at runtime</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>then <code>extra</code> can be called on the object</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>and <code>doSomething</code> is still callable</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When coercing an object to a trait, the result of the operation is not the same instance. It is guaranteed
that the coerced object will implement both the trait <strong>and</strong> the interfaces that the original object implements, but
the result will <strong>not</strong> be an instance of the original class.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_multiple_traits_at_once"><a class="anchor" href="#_implementing_multiple_traits_at_once"></a>11.2. Implementing multiple traits at once</h3>
<div class="paragraph">
<p>Should you need to implement several traits at once, you can use the <code>withTraits</code> method instead of the <code>as</code> keyword:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait A { void methodFromA() {} }
trait B { void methodFromB() {} }

class C {}

def c = new C()
c.methodFromA()                     <i class="conum" data-value="1"></i><b>(1)</b>
c.methodFromB()                     <i class="conum" data-value="2"></i><b>(2)</b>
def d = c.withTraits A, B           <i class="conum" data-value="3"></i><b>(3)</b>
d.methodFromA()                     <i class="conum" data-value="4"></i><b>(4)</b>
d.methodFromB()                     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>call to <code>methodFromA</code> will fail because <code>C</code> doesn&#8217;t implement <code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>call to <code>methodFromB</code> will fail because <code>C</code> doesn&#8217;t implement <code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>withTrait</code> will wrap <code>c</code> into something which implements <code>A</code> and <code>B</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>methodFromA</code> will now pass because <code>d</code> implements <code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>methodFromB</code> will now pass because <code>d</code> also implements <code>B</code></td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When coercing an object to multiple traits, the result of the operation is not the same instance. It is guaranteed
that the coerced object will implement both the traits <strong>and</strong> the interfaces that the original object implements, but
the result will <strong>not</strong> be an instance of the original class.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_chaining_behavior"><a class="anchor" href="#_chaining_behavior"></a>12. Chaining behavior</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy supports the concept of <em>stackable traits</em>. The idea is to delegate from one trait to the other if the current trait
is not capable of handling a message. To illustrate this, let&#8217;s imagine a message handler interface like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">interface MessageHandler {
    void on(String message, Map payload)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can compose a message handler by applying small behaviors. For example, let&#8217;s define a default handler in the
form of a trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait DefaultHandler implements MessageHandler {
    void on(String message, Map payload) {
        println "Received $message with payload $payload"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then any class can inherit the behavior of the default handler by implementing the trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandler implements DefaultHandler {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now what if you want to log all messages, in addition to the default handler? One option is to write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SimpleHandlerWithLogging implements DefaultHandler {
    void on(String message, Map payload) {                                  <i class="conum" data-value="1"></i><b>(1)</b>
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        DefaultHandler.super.on(message, payload)                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>explicitly implement the <code>on</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>perform logging</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>continue by delegating to the <code>DefaultHandler</code> trait</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This works but this approach has drawbacks:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the logging logic is bound to a "concrete" handler</p>
</li>
<li>
<p>we have an explicit reference to <code>DefaultHandler</code> in the <code>on</code> method, meaning that if we happen to change the trait that our class implements, code will be broken</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As an alternative, we can write another trait which responsibility is limited to logging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait LoggingHandler implements MessageHandler {                            <i class="conum" data-value="1"></i><b>(1)</b>
    void on(String message, Map payload) {
        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>
        super.on(message, payload)                                          <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the logging handler is itself a handler</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>prints the message it receives</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>then <code>super</code> makes it delegate the call to the next trait in the chain</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then our class can be rewritten as this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class HandlerWithLogger implements DefaultHandler, LoggingHandler {}
def loggingHandler = new HandlerWithLogger()
loggingHandler.on('test logging', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>which will print:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing test logging with payload [:]
Received test logging with payload [:]</pre>
</div>
</div>
<div class="paragraph">
<p>As the priority rules imply that <code>LoggerHandler</code> wins because it is declared last, then a call to <code>on</code> will use
the implementation from <code>LoggingHandler</code>. But the latter has a call to <code>super</code>, which means the next trait in the
chain. Here, the next trait is <code>DefaultHandler</code> so <strong>both</strong> will be called:</p>
</div>
<div class="paragraph">
<p>The interest of this approach becomes more evident if we add a third handler, which is responsible for handling messages
that start with <code>say</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait SayHandler implements MessageHandler {
    void on(String message, Map payload) {
        if (message.startsWith("say")) {                                    <i class="conum" data-value="1"></i><b>(1)</b>
            println "I say ${message - 'say'}!"
        } else {
            super.on(message, payload)                                      <i class="conum" data-value="2"></i><b>(2)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>a handler specific precondition</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>if the precondition is not met, pass the message to the next handler in the chain</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then our final handler looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Handler implements DefaultHandler, SayHandler, LoggingHandler {}
def h = new Handler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>messages will first go through the logging handler</p>
</li>
<li>
<p>the logging handler calls <code>super</code> which will delegate to the next handler, which is the <code>SayHandler</code></p>
</li>
<li>
<p>if the message starts with <code>say</code>, then the handler consumes the message</p>
</li>
<li>
<p>if not, the <code>say</code> handler delegates to the next handler in the chain</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach is very powerful because it allows you to write handlers that do not know each other and yet let you
combine them in the order you want. For example, if we execute the code, it will print:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
Seeing sayHello with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>but if we move the logging handler to be the second one in the chain, the output is different:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}
h = new AlternateHandler()
h.on('foo', [:])
h.on('sayHello', [:])</code></pre>
</div>
</div>
<div class="paragraph">
<p>prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Seeing foo with payload [:]
Received foo with payload [:]
I say Hello!</pre>
</div>
</div>
<div class="paragraph">
<p>The reason is that now, since the <code>SayHandler</code> consumes the message without calling <code>super</code>, the logging handler is
not called anymore.</p>
</div>
<div class="sect2">
<h3 id="_semantics_of_super_inside_a_trait"><a class="anchor" href="#_semantics_of_super_inside_a_trait"></a>12.1. Semantics of super inside a trait</h3>
<div class="paragraph">
<p>If a class implements multiple traits and a call to an unqualified <code>super</code> is found, then:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>if the class implements another trait, the call delegates to the next trait in the chain</p>
</li>
<li>
<p>if there isn&#8217;t any trait left in the chain, <code>super</code> refers to the super class of the implementing class (<em>this</em>)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, it is possible to decorate final classes thanks to this behavior:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Filtering {                                       <i class="conum" data-value="1"></i><b>(1)</b>
    StringBuilder append(String str) {                  <i class="conum" data-value="2"></i><b>(2)</b>
        def subst = str.replace('o','')                 <i class="conum" data-value="3"></i><b>(3)</b>
        super.append(subst)                             <i class="conum" data-value="4"></i><b>(4)</b>
    }
    String toString() { super.toString() }              <i class="conum" data-value="5"></i><b>(5)</b>
}
def sb = new StringBuilder().withTraits Filtering       <i class="conum" data-value="6"></i><b>(6)</b>
sb.append('Groovy')
assert sb.toString() == 'Grvy'                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>define a trait named <code>Filtering</code>, supposed to be applied on a <code>StringBuilder</code> at runtime</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>redefine the <code>append</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>remove all 'o&#8217;s from the string</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>then delegate to <code>super</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>in case <code>toString</code> is called, delegate to <code>super.toString</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>runtime implementation of the <code>Filtering</code> trait on a <code>StringBuilder</code> instance</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>the string which has been appended no longer contains the letter <code>o</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example, when <code>super.append</code> is encountered, there is no other trait implemented by the target object, so the
method which is called is the original <code>append</code> method, that is to say the one from <code>StringBuilder</code>. The same trick
is used for <code>toString</code>, so that the string representation of the proxy object which is generated delegates to the
<code>toString</code> of the <code>StringBuilder</code> instance.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_features"><a class="anchor" href="#_advanced_features"></a>13. Advanced features</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_sam_type_coercion"><a class="anchor" href="#_sam_type_coercion"></a>13.1. SAM type coercion</h3>
<div class="paragraph">
<p>If a trait defines a single abstract method, it is candidate for SAM (Single Abstract Method) type coercion. For example,
imagine the following trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Greeter {
    String greet() { "Hello $name" }        <i class="conum" data-value="1"></i><b>(1)</b>
    abstract String getName()               <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>greet</code> method is not abstract and calls the abstract method <code>getName</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>getName</code> is an abstract method</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since <code>getName</code> is the <em>single abstract method</em> in the <code>Greeter</code> trait, you can write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Greeter greeter = { 'Alice' }               <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the closure "becomes" the implementation of the <code>getName</code> single abstract method</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>or even:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">void greet(Greeter g) { println g.greet() } <i class="conum" data-value="1"></i><b>(1)</b>
greet { 'Alice' }                           <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the greet method accepts the SAM type Greeter as parameter</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>we can call it directly with a closure</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_differences_with_java_8_default_methods"><a class="anchor" href="#_differences_with_java_8_default_methods"></a>13.2. Differences with Java 8 default methods</h3>
<div class="paragraph">
<p>In Java 8, interfaces can have default implementations of methods. If a class implements an interface and does not provide
an implementation for a default method, then the implementation from the interface is chosen. Traits behave the same but
with a major difference: the implementation from the trait is <strong>always</strong> used if the class declares the trait in its interface
list <strong>and</strong> that it doesn&#8217;t provide an implementation <strong>even</strong> if a super class does.</p>
</div>
<div class="paragraph">
<p>This feature can be used to compose behaviors in an very precise way, in case you want to override the behavior of an
already implemented method.</p>
</div>
<div class="paragraph">
<p>To illustrate the concept, let&#8217;s start with this simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.CompileStatic
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

class SomeTest extends GroovyTestCase {
    def config
    def shell

    void setup() {
        config = new CompilerConfiguration()
        shell = new GroovyShell(config)
    }
    void testSomething() {
        assert shell.evaluate('1+1') == 2
    }
    void otherTest() { /* ... */ }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we create a simple test case which uses two properties (<em>config</em> and <em>shell</em>) and uses those in
multiple test methods. Now imagine that you want to test the same, but with another distinct compiler configuration.
One option is to create a subclass of <code>SomeTest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It works, but what if you have actually multiple test classes, and that you want to test the new configuration for all
those test classes? Then you would have to create a distinct subclass for each test class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class YetAnotherTest extends SomeTest {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( ... )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then what you see is that the <code>setup</code> method of both tests is the same. The idea, then, is to create a trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait MyTestSupport {
    void setup() {
        config = new CompilerConfiguration()
        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )
        shell = new GroovyShell(config)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then use it in the subclasses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class AnotherTest extends SomeTest implements MyTestSupport {}
class YetAnotherTest extends SomeTest2 implements MyTestSupport {}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>It would allow us to dramatically reduce the boilerplate code, and reduces the risk of forgetting to change the setup
code in case we decide to change it. Even if <code>setup</code> is already implemented in the super class, since the test class declares
the trait in its interface list, the behavior will be borrowed from the trait implementation!</p>
</div>
<div class="paragraph">
<p>This feature is in particular useful when you don&#8217;t have access to the super class source code. It can be used to
mock methods or force a particular implementation of a method in a subclass. It lets you refactor your code to keep
the overridden logic in a single trait and inherit a new behavior just by implementing it. The alternative, of course,
is to override the method in <strong>every</strong> place you would have used the new code.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It&#8217;s worth noting that if you use runtime traits, the methods from the trait are <strong>always</strong> preferred to those of the proxied
object:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Person {
    String name                                         <i class="conum" data-value="1"></i><b>(1)</b>
}
trait Bob {
    String getName() { 'Bob' }                          <i class="conum" data-value="2"></i><b>(2)</b>
}

def p = new Person(name: 'Alice')
assert p.name == 'Alice'                                <i class="conum" data-value="3"></i><b>(3)</b>
def p2 = p as Bob                                       <i class="conum" data-value="4"></i><b>(4)</b>
assert p2.name == 'Bob'                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the <code>Person</code> class defines a <code>name</code> property which results in a <code>getName</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Bob</code> is a trait which defines <code>getName</code> as returning <code>Bob</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the default object will return <em>Alice</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>p2</code> coerces <code>p</code> into <code>Bob</code> at runtime</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>getName</code> returns <em>Bob</em> because <code>getName</code> is taken from the <strong>trait</strong></td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Again, don&#8217;t forget that dynamic trait coercion returns a distinct object which only implements the original
interfaces, as well as the traits.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_differences_with_mixins"><a class="anchor" href="#_differences_with_mixins"></a>14. Differences with mixins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several conceptual differences with mixins, as they are available in Groovy. Note that we are talking about
runtime mixins, not the @Mixin annotation which is deprecated in favour of traits.</p>
</div>
<div class="paragraph">
<p>First of all, methods defined in a trait are visible in bytecode:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>internally, the trait is represented as an interface (without default methods) and several helper classes</p>
</li>
<li>
<p>this means that an object implementing a trait effectively implements an <em>interface</em></p>
</li>
<li>
<p>those methods are visible from Java</p>
</li>
<li>
<p>they are compatible with type checking and static compilation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Methods added through a mixin are, on the contrary, only visible at runtime:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class A { String methodFromA() { 'A' } }        <i class="conum" data-value="1"></i><b>(1)</b>
class B { String methodFromB() { 'B' } }        <i class="conum" data-value="2"></i><b>(2)</b>
A.metaClass.mixin B                             <i class="conum" data-value="3"></i><b>(3)</b>
def o = new A()
assert o.methodFromA() == 'A'                   <i class="conum" data-value="4"></i><b>(4)</b>
assert o.methodFromB() == 'B'                   <i class="conum" data-value="5"></i><b>(5)</b>
assert o instanceof A                           <i class="conum" data-value="6"></i><b>(6)</b>
assert !(o instanceof B)                        <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class <code>A</code> defines <code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>class <code>B</code> defines <code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>mixin B into A</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>we can call <code>methodFromA</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>we can also call <code>methodFromB</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>the object is an instance of <code>A</code></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>but it&#8217;s <strong>not</strong> an instanceof <code>B</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The last point is actually a very important and illustrates a place where mixins have an advantage over traits: the instances
are <strong>not</strong> modified, so if you mixin some class into another, there isn&#8217;t a third class generated, and methods which respond to
A will continue responding to A even if mixed in.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_static_methods_properties_and_fields"><a class="anchor" href="#_static_methods_properties_and_fields"></a>15. Static methods, properties and fields</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The following instructions are subject to caution. Static member support is work in progress and still experimental. The
information below is valid for 3.0.0-alpha-3 only.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is possible to define static methods in a trait, but it comes with numerous limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>traits with static methods cannot be compiled statically or type checked. All static methods/properties/field are accessed dynamically (it&#8217;s a limitation from the JVM).</p>
</li>
<li>
<p>the trait is interpreted as a <em>template</em> for the implementing class, which means that each implementing class will get its own static methods/properties/methods. So a
static member declared on a trait doesn&#8217;t belong to the <code>Trait</code>, but to it&#8217;s implementing class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait TestHelper {
    public static boolean CALLED = false        <i class="conum" data-value="1"></i><b>(1)</b>
    static void init() {                        <i class="conum" data-value="2"></i><b>(2)</b>
        CALLED = true                           <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
class Foo implements TestHelper {}
Foo.init()                                      <i class="conum" data-value="4"></i><b>(4)</b>
assert Foo.TestHelper__CALLED                   <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the static field is declared in the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>a static method is also declared in the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the static field is updated <em>within</em> the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>a static method <em>init</em> is made available to the implementing class</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>the static field is <em>remapped</em> to avoid the diamond issue</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As usual, it is not recommended to use public fields. Anyway, should you want this, you must understand that the following code would fail:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">Foo.CALLED = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>because there is <em>no</em> static field <em>CALLED</em> defined on the trait itself. Likewise, if you have two distinct implementing classes, each one gets a distinct static field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Bar implements TestHelper {}              <i class="conum" data-value="1"></i><b>(1)</b>
class Baz implements TestHelper {}              <i class="conum" data-value="2"></i><b>(2)</b>
Bar.init()                                      <i class="conum" data-value="3"></i><b>(3)</b>
assert Bar.TestHelper__CALLED                   <i class="conum" data-value="4"></i><b>(4)</b>
assert !Baz.TestHelper__CALLED                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>class <code>Bar</code> implements the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>class <code>Baz</code> also implements the trait</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>init</code> is only called on <code>Bar</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the static field <code>CALLED</code> on <code>Bar</code> is updated</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>but the static field <code>CALLED</code> on <code>Baz</code> is not, because it is <strong>distinct</strong></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_inheritance_of_state_gotchas"><a class="anchor" href="#_inheritance_of_state_gotchas"></a>16. Inheritance of state gotchas</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have seen that traits are stateful. It is possible for a trait to define fields or properties, but when a class implements a trait, it gets those fields/properties on
a per-trait basis. So consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { x+y }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The trait defines two properties, <code>x</code> and <code>y</code>, as well as a <code>sum</code> method. Now let&#8217;s create a class which implements the trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class BaseElem implements IntCouple {
    int f() { sum() }
}
def base = new BaseElem()
assert base.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result of calling <code>f</code> is <code>3</code>, because <code>f</code> delegates to <code>sum</code> in the trait, which has state. But what if we write this instead?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class Elem implements IntCouple {
    int x = 3                                       <i class="conum" data-value="1"></i><b>(1)</b>
    int y = 4                                       <i class="conum" data-value="2"></i><b>(2)</b>
    int f() { sum() }                               <i class="conum" data-value="3"></i><b>(3)</b>
}
def elem = new Elem()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Override property <code>x</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Override property <code>y</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Call <code>sum</code> from trait</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you call <code>elem.f()</code>, what is the expected output? Actually it is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">assert elem.f() == 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason is that the <code>sum</code> method accesses the <em>fields</em> of the trait. So it is using the <code>x</code> and <code>y</code> values defined
in the trait. If you want to use the values from the implementing class, then you need to dereference fields by using
getters and setters, like in this last example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait IntCouple {
    int x = 1
    int y = 2
    int sum() { getX()+getY() }
}

class Elem implements IntCouple {
    int x = 3
    int y = 4
    int f() { sum() }
}
def elem = new Elem()
assert elem.f() == 7</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_self_types"><a class="anchor" href="#_self_types"></a>17. Self types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_type_constraints_on_traits"><a class="anchor" href="#_type_constraints_on_traits"></a>17.1. Type constraints on traits</h3>
<div class="paragraph">
<p>Sometimes you will want to write a trait that can only be applied to some type. For example, you may want to apply a
trait on a class that extends another class which is beyond your control, and still be able to call those methods.
To illustrate this, let&#8217;s start with this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class CommunicationService {
    static void sendMessage(String from, String to, String message) {       <i class="conum" data-value="1"></i><b>(1)</b>
        println "$from sent [$message] to $to"
    }
}

class Device { String id }                                                  <i class="conum" data-value="2"></i><b>(2)</b>

trait Communicating {
    void sendMessage(Device to, String message) {
        CommunicationService.sendMessage(id, to.id, message)                <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

class MyDevice extends Device implements Communicating {}                   <i class="conum" data-value="4"></i><b>(4)</b>

def bob = new MyDevice(id:'Bob')
def alice = new MyDevice(id:'Alice')
bob.sendMessage(alice,'secret')                                             <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A <code>Service</code> class, beyond your control (in a library, &#8230;&#8203;) defines a <code>sendMessage</code> method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>Device</code> class, beyond your control (in a library, &#8230;&#8203;)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines a communicating trait for devices that can call the service</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Defines <code>MyDevice</code> as a communicating device</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The method from the trait is called, and <code>id</code> is resolved</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is clear, here, that the <code>Communicating</code> trait can only apply to <code>Device</code>. However, there&#8217;s no explicit
contract to tell that, because traits cannot extend classes. However, the code compiles and runs perfectly
fine, because <code>id</code> in the trait method will be resolved dynamically. The problem is that there is nothing that
prevents the trait from being applied to any class which is <strong>not</strong> a <code>Device</code>. Any class which has an <code>id</code> would
work, while any class that does not have an <code>id</code> property would cause a runtime error.</p>
</div>
<div class="paragraph">
<p>The problem is even more complex if you want to enable type checking or apply <code>@CompileStatic</code> on the trait: because
the trait knows nothing about itself being a <code>Device</code>, the type checker will complain saying that it does not find
the <code>id</code> property.</p>
</div>
<div class="paragraph">
<p>One possibility is to explicitly add a <code>getId</code> method in the trait, but it would not solve all issues. What if a method
requires <code>this</code> as a parameter, and actually requires it to be a <code>Device</code>?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class SecurityService {
    static void check(Device d) { if (d.id==null) throw new SecurityException() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to be able to call this in the trait, then you will explicitly need to cast <code>this</code> into a <code>Device</code>. This can
quickly become unreadable with explicit casts to this everywhere.</p>
</div>
</div>
<div class="sect2">
<h3 id="traits-selftype"><a class="anchor" href="#traits-selftype"></a>17.2. The @SelfType annotation</h3>
<div class="paragraph">
<p>In order to make this contract explicit, and to make the type checker aware of the <em>type of itself</em>, Groovy provides
a <code>@SelfType</code> annotation that will:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>let you declare the types that a class that implements this trait must inherit or implement</p>
</li>
<li>
<p>throw a compile time error if those type constraints are not satisfied</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So in our previous example, we can fix the trait using the <code>@groovy.transform.SelfType</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">@SelfType(Device)
@CompileStatic
trait Communicating {
    void sendMessage(Device to, String message) {
        SecurityService.check(this)
        CommunicationService.sendMessage(id, to.id, message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if you try to implement this trait on a class that is <strong>not</strong> a device, a compile-time error will occur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">class MyDevice implements Communicating {} // forgot to extend Device</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class 'MyDevice' implements trait 'Communicating' but does not extend self type class 'Device'</pre>
</div>
</div>
<div class="paragraph">
<p>In conclusion, self types are a powerful way of declaring constraints on traits without having to declare the contract
directly in the trait or having to use casts everywhere, maintaining separation of concerns as tight as it should be.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations"><a class="anchor" href="#_limitations"></a>18. Limitations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_compatibility_with_ast_transformations"><a class="anchor" href="#_compatibility_with_ast_transformations"></a>18.1. Compatibility with AST transformations</h3>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Traits are not officially compatible with AST transformations. Some of them, like <code>@CompileStatic</code> will be applied
on the trait itself (not on implementing classes), while others will apply on both the implementing class and the trait.
There is absolutely no guarantee that an AST transformation will run on a trait as it does on a regular class, so use it
at your own risk!
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_prefix_and_postfix_operations"><a class="anchor" href="#_prefix_and_postfix_operations"></a>18.2. Prefix and postfix operations</h3>
<div class="paragraph">
<p>Within traits, prefix and postfix operations are not allowed if they update a field of the trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">trait Counting {
    int x
    void inc() {
        x++                             <i class="conum" data-value="1"></i><b>(1)</b>
    }
    void dec() {
        --x                             <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
class Counter implements Counting {}
def c = new Counter()
c.inc()</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>x</code> is defined within the trait, postfix increment is not allowed</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>x</code> is defined within the trait, prefix decrement is not allowed</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A workaround is to use the <code>+=</code> operator instead.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 3.0.0-alpha-3<br>
Last updated 2018-06-23 13:44:35 AEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>